//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode, AstTokenChildren},
    SolidityLang,
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl Path {
    pub fn string_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![string])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Symbol {
    pub(crate) syntax: SyntaxNode,
}
impl Symbol {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPath {
    pub(crate) syntax: SyntaxNode,
}
impl IdentPath {
    pub fn segment(&self) -> AstChildren<NameRef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPathType {
    pub(crate) syntax: SyntaxNode,
}
impl IdentPathType {
    pub fn segment(&self) -> AstChildren<NameRef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DataLocation {
    pub(crate) syntax: SyntaxNode,
}
impl DataLocation {
    pub fn memory_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![memory])
    }
    pub fn storage_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![storage])
    }
    pub fn calldata_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![calldata])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UserDefineableOperator {
    pub(crate) syntax: SyntaxNode,
}
impl UserDefineableOperator {
    pub fn amp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&])
    }
    pub fn tilde_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![~])
    }
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn caret_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![^])
    }
    pub fn plus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![+])
    }
    pub fn slash_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![/])
    }
    pub fn percent_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![%])
    }
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![-])
    }
    pub fn eq2_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![==])
    }
    pub fn r_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>])
    }
    pub fn geq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![>=])
    }
    pub fn l_angle_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<])
    }
    pub fn leq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![<=])
    }
    pub fn neq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StringLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl StringLiteral {
    pub fn string_tokens(&self) -> AstTokenChildren {
        support::tokens(&self.syntax, T![string])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HexStringLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl HexStringLiteral {
    pub fn hex_string_tokens(&self) -> AstTokenChildren {
        support::tokens(&self.syntax, T![hex_string])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DecimalNumberLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl DecimalNumberLiteral {
    pub fn decimal_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![decimal_number])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HexNumberLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl HexNumberLiteral {
    pub fn hex_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![hex_number])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BoolLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl BoolLiteral {
    pub fn true_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![true])
    }
    pub fn false_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![false])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElementaryType {
    pub(crate) syntax: SyntaxNode,
}
impl ElementaryType {
    pub fn elementary_type_ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![elementary_type_ident])
    }
    pub fn payable_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![payable])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitSource {
    pub(crate) syntax: SyntaxNode,
}
impl UnitSource {
    pub fn items(&self) -> AstChildren<Item> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Pragma {
    pub(crate) syntax: SyntaxNode,
}
impl Pragma {
    pub fn pragma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pragma])
    }
    pub fn data(&self) -> AstChildren<PragmaData> {
        support::children(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Import {
    pub(crate) syntax: SyntaxNode,
}
impl Import {
    pub fn import_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![import])
    }
    pub fn import_item(&self) -> Option<ImportItem> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Using {
    pub(crate) syntax: SyntaxNode,
}
impl Using {
    pub fn using_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![using])
    }
    pub fn using_item(&self) -> Option<UsingItem> {
        support::child(&self.syntax)
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn using_target(&self) -> Option<UsingTarget> {
        support::child(&self.syntax)
    }
    pub fn global_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![global])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Contract {
    pub(crate) syntax: SyntaxNode,
}
impl Contract {
    pub fn abstract_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![abstract])
    }
    pub fn contract_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![contract])
    }
    pub fn interface_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![interface])
    }
    pub fn library_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![library])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn inheritance(&self) -> Option<Inheritance> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn contract_items(&self) -> AstChildren<ContractItem> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl NamedFunctionDefinition {
    pub fn function_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![function])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn fallback_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![fallback])
    }
    pub fn receive_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![receive])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn function_attributes(&self) -> AstChildren<FunctionAttribute> {
        support::children(&self.syntax)
    }
    pub fn returns(&self) -> Option<Returns> {
        support::child(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StateVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl StateVariableDeclaration {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn state_variable_attributes(&self) -> AstChildren<StateVariableAttribute> {
        support::children(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl StructDefinition {
    pub fn struct_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![struct])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn struct_members(&self) -> AstChildren<StructMember> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl EnumDefinition {
    pub fn enum_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![enum])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn enum_members(&self) -> AstChildren<EnumMember> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UserDefinedValueTypeDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl UserDefinedValueTypeDefinition {
    pub fn type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![type])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn is_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![is])
    }
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ErrorDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl ErrorDefinition {
    pub fn error_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![error])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn error_parameters(&self) -> AstChildren<ErrorParameter> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EventDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl EventDefinition {
    pub fn event_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![event])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn event_parameters(&self) -> AstChildren<EventParameter> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn anonymous_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![anonymous])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PragmaData {
    pub(crate) syntax: SyntaxNode,
}
impl PragmaData {
    pub fn pragma_token_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pragma_token])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportPath {
    pub(crate) syntax: SyntaxNode,
}
impl ImportPath {
    pub fn path(&self) -> Option<Path> {
        support::child(&self.syntax)
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportSymbols {
    pub(crate) syntax: SyntaxNode,
}
impl ImportSymbols {
    pub fn symbol_aliases(&self) -> Option<SymbolAliases> {
        support::child(&self.syntax)
    }
    pub fn symbol_alias(&self) -> Option<SymbolAlias> {
        support::child(&self.syntax)
    }
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    pub fn path(&self) -> Option<Path> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SymbolAliases {
    pub(crate) syntax: SyntaxNode,
}
impl SymbolAliases {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn symbol_aliases(&self) -> AstChildren<SymbolAlias> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SymbolAlias {
    pub(crate) syntax: SyntaxNode,
}
impl SymbolAlias {
    pub fn symbol(&self) -> Option<Symbol> {
        support::child(&self.syntax)
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UsingTarget {
    pub(crate) syntax: SyntaxNode,
}
impl UsingTarget {
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UsingAliases {
    pub(crate) syntax: SyntaxNode,
}
impl UsingAliases {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn using_aliases(&self) -> AstChildren<UsingAlias> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UsingAlias {
    pub(crate) syntax: SyntaxNode,
}
impl UsingAlias {
    pub fn ident_path(&self) -> Option<IdentPath> {
        support::child(&self.syntax)
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn user_defineable_operator(&self) -> Option<UserDefineableOperator> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionType {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionType {
    pub fn function_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![function])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn function_modifiers(&self) -> AstChildren<FunctionModifier> {
        support::children(&self.syntax)
    }
    pub fn returns(&self) -> Option<Returns> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MappingType {
    pub(crate) syntax: SyntaxNode,
}
impl MappingType {
    pub fn mapping_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![mapping])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn key(&self) -> Option<MappingKey> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn val(&self) -> Option<MappingValue> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayType {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParameterList {
    pub(crate) syntax: SyntaxNode,
}
impl ParameterList {
    pub fn variable_declarations(&self) -> AstChildren<VariableDeclaration> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionModifier {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionModifier {
    pub fn internal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![internal])
    }
    pub fn external_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![external])
    }
    pub fn private_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![private])
    }
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
    pub fn pure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pure])
    }
    pub fn view_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![view])
    }
    pub fn payable_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![payable])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Returns {
    pub(crate) syntax: SyntaxNode,
}
impl Returns {
    pub fn returns_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![returns])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl VariableDeclaration {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn location(&self) -> Option<DataLocation> {
        support::child(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MappingKey {
    pub(crate) syntax: SyntaxNode,
}
impl MappingKey {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MappingValue {
    pub(crate) syntax: SyntaxNode,
}
impl MappingValue {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SliceExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SliceExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberAccessExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MemberAccessExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn dot_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![.])
    }
    pub fn field(&self) -> Option<NameRef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NewExpr {
    pub(crate) syntax: SyntaxNode,
}
impl NewExpr {
    pub fn new_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![new])
    }
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TypeExpr {
    pub fn type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![type])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl InfixExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PostfixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PostfixExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallOptionsExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CallOptionsExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn options(&self) -> Option<CallOptions> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn call_argument_list(&self) -> Option<CallArgumentList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TernaryExpr {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TupleExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IdentExpr {
    pub fn name_ref(&self) -> Option<NameRef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralExpr {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallOptions {
    pub(crate) syntax: SyntaxNode,
}
impl CallOptions {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn call_options(&self) -> AstChildren<CallOption> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallOption {
    pub(crate) syntax: SyntaxNode,
}
impl CallOption {
    pub fn name_ref(&self) -> Option<NameRef> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallArguments {
    pub(crate) syntax: SyntaxNode,
}
impl CallArguments {
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedCallArguments {
    pub(crate) syntax: SyntaxNode,
}
impl NamedCallArguments {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn named_call_arguments(&self) -> AstChildren<NamedCallArgument> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedCallArgument {
    pub(crate) syntax: SyntaxNode,
}
impl NamedCallArgument {
    pub fn name_ref(&self) -> Option<NameRef> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Inheritance {
    pub(crate) syntax: SyntaxNode,
}
impl Inheritance {
    pub fn is_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![is])
    }
    pub fn inheritance_specifiers(&self) -> AstChildren<InheritanceSpecifier> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InheritanceSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl InheritanceSpecifier {
    pub fn ident_path(&self) -> Option<IdentPath> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn call_argument_list(&self) -> Option<CallArgumentList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstructorDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl ConstructorDefinition {
    pub fn constructor_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![constructor])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn function_attributes(&self) -> AstChildren<FunctionAttribute> {
        support::children(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModifierDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl ModifierDefinition {
    pub fn modifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![modifier])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn modifier_attributes(&self) -> AstChildren<ModifierAttribute> {
        support::children(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FallbackFunctionDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl FallbackFunctionDefinition {
    pub fn fallback_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![fallback])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn function_attributes(&self) -> AstChildren<FunctionAttribute> {
        support::children(&self.syntax)
    }
    pub fn returns(&self) -> Option<Returns> {
        support::child(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReceiveFunctionDefinition {
    pub(crate) syntax: SyntaxNode,
}
impl ReceiveFunctionDefinition {
    pub fn receive_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![receive])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn function_attributes(&self) -> AstChildren<FunctionAttribute> {
        support::children(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionAttribute {
    pub fn internal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![internal])
    }
    pub fn external_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![external])
    }
    pub fn private_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![private])
    }
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
    pub fn pure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pure])
    }
    pub fn view_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![view])
    }
    pub fn payable_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![payable])
    }
    pub fn virtual_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![virtual])
    }
    pub fn modifier_invocation(&self) -> Option<ModifierInvocation> {
        support::child(&self.syntax)
    }
    pub fn override_specifier(&self) -> Option<OverrideSpecifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}
impl Block {
    pub fn unchecked_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![unchecked])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModifierAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl ModifierAttribute {
    pub fn virtual_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![virtual])
    }
    pub fn override_specifier(&self) -> Option<OverrideSpecifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OverrideSpecifier {
    pub(crate) syntax: SyntaxNode,
}
impl OverrideSpecifier {
    pub fn override_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![override])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_paths(&self) -> AstChildren<IdentPath> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModifierInvocation {
    pub(crate) syntax: SyntaxNode,
}
impl ModifierInvocation {
    pub fn ident_path(&self) -> Option<IdentPath> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn call_argument_list(&self) -> Option<CallArgumentList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructMember {
    pub(crate) syntax: SyntaxNode,
}
impl StructMember {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumMember {
    pub(crate) syntax: SyntaxNode,
}
impl EnumMember {
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StateVariableAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl StateVariableAttribute {
    pub fn internal_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![internal])
    }
    pub fn external_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![external])
    }
    pub fn private_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![private])
    }
    pub fn public_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![public])
    }
    pub fn const_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![const])
    }
    pub fn immutable_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![immutable])
    }
    pub fn override_specifier(&self) -> Option<OverrideSpecifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EventParameter {
    pub(crate) syntax: SyntaxNode,
}
impl EventParameter {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn indexed_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![indexed])
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ErrorParameter {
    pub(crate) syntax: SyntaxNode,
}
impl ErrorParameter {
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    pub fn name(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IfStmt {
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn cond(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn body(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
    pub fn elseBody(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclarationStmt {
    pub(crate) syntax: SyntaxNode,
}
impl VariableDeclarationStmt {
    pub fn variable_declaration_item(&self) -> Option<VariableDeclarationItem> {
        support::child(&self.syntax)
    }
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    pub fn init(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr_stmt(&self) -> Option<ExprStmt> {
        support::child(&self.syntax)
    }
    pub fn variable_declaration_stmt(&self) -> Option<VariableDeclarationStmt> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl WhileStmt {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn cond(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoWhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DoWhileStmt {
    pub fn do_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![do])
    }
    pub fn stmt(&self) -> Option<Stmt> {
        support::child(&self.syntax)
    }
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn cond(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryStmt {
    pub(crate) syntax: SyntaxNode,
}
impl TryStmt {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn returns(&self) -> Option<Returns> {
        support::child(&self.syntax)
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    pub fn catch_clauses(&self) -> AstChildren<CatchClause> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnStmt {
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EmitStmt {
    pub(crate) syntax: SyntaxNode,
}
impl EmitStmt {
    pub fn emit_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![emit])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn call_argument_list(&self) -> Option<CallArgumentList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RevertStmt {
    pub(crate) syntax: SyntaxNode,
}
impl RevertStmt {
    pub fn revert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![revert])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn call_argument_list(&self) -> Option<CallArgumentList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssemblyStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssemblyStmt {
    pub fn assembly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assembly])
    }
    pub fn assembly_flags(&self) -> AstChildren<AssemblyFlag> {
        support::children(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableTupleDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl VariableTupleDeclaration {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn variable_tuple_elements(&self) -> AstChildren<VariableTupleElement> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableTupleElement {
    pub(crate) syntax: SyntaxNode,
}
impl VariableTupleElement {
    pub fn variable_declaration(&self) -> Option<VariableDeclaration> {
        support::child(&self.syntax)
    }
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CatchClause {
    pub(crate) syntax: SyntaxNode,
}
impl CatchClause {
    pub fn catch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![catch])
    }
    pub fn name_ref(&self) -> Option<NameRef> {
        support::child(&self.syntax)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn parameter_list(&self) -> Option<ParameterList> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn block(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssemblyFlag {
    pub(crate) syntax: SyntaxNode,
}
impl AssemblyFlag {
    pub fn string_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![string])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Literal {
    StringLiteral(StringLiteral),
    HexStringLiteral(HexStringLiteral),
    DecimalNumberLiteral(DecimalNumberLiteral),
    HexNumberLiteral(HexNumberLiteral),
    BoolLiteral(BoolLiteral),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Pragma(Pragma),
    Import(Import),
    Using(Using),
    Contract(Contract),
    NamedFunctionDefinition(NamedFunctionDefinition),
    StateVariableDeclaration(StateVariableDeclaration),
    StructDefinition(StructDefinition),
    EnumDefinition(EnumDefinition),
    UserDefinedValueTypeDefinition(UserDefinedValueTypeDefinition),
    ErrorDefinition(ErrorDefinition),
    EventDefinition(EventDefinition),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportItem {
    ImportPath(ImportPath),
    ImportSymbols(ImportSymbols),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UsingItem {
    IdentPath(IdentPath),
    UsingAliases(UsingAliases),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ElementaryType(ElementaryType),
    FunctionType(FunctionType),
    MappingType(MappingType),
    IdentPathType(IdentPathType),
    ArrayType(ArrayType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    IndexExpr(IndexExpr),
    SliceExpr(SliceExpr),
    MemberAccessExpr(MemberAccessExpr),
    NewExpr(NewExpr),
    TypeExpr(TypeExpr),
    InfixExpr(InfixExpr),
    PrefixExpr(PrefixExpr),
    PostfixExpr(PostfixExpr),
    CallOptionsExpr(CallOptionsExpr),
    CallExpr(CallExpr),
    TernaryExpr(TernaryExpr),
    TupleExpr(TupleExpr),
    IdentExpr(IdentExpr),
    LiteralExpr(LiteralExpr),
    ElementaryType(ElementaryType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MappingKeyType {
    ElementaryType(ElementaryType),
    IdentPath(IdentPath),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CallArgumentList {
    CallArguments(CallArguments),
    NamedCallArguments(NamedCallArguments),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ContractItem {
    ConstructorDefinition(ConstructorDefinition),
    ModifierDefinition(ModifierDefinition),
    NamedFunctionDefinition(NamedFunctionDefinition),
    FallbackFunctionDefinition(FallbackFunctionDefinition),
    ReceiveFunctionDefinition(ReceiveFunctionDefinition),
    StructDefinition(StructDefinition),
    EnumDefinition(EnumDefinition),
    UserDefinedValueTypeDefinition(UserDefinedValueTypeDefinition),
    StateVariableDeclaration(StateVariableDeclaration),
    EventDefinition(EventDefinition),
    ErrorDefinition(ErrorDefinition),
    Using(Using),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionDefinition {
    NamedFunctionDefinition(NamedFunctionDefinition),
    FallbackFunctionDefinition(FallbackFunctionDefinition),
    ReceiveFunctionDefinition(ReceiveFunctionDefinition),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    Block(Block),
    ExprStmt(ExprStmt),
    IfStmt(IfStmt),
    VariableDeclarationStmt(VariableDeclarationStmt),
    ForStmt(ForStmt),
    WhileStmt(WhileStmt),
    DoWhileStmt(DoWhileStmt),
    ContinueStmt(ContinueStmt),
    BreakStmt(BreakStmt),
    TryStmt(TryStmt),
    ReturnStmt(ReturnStmt),
    EmitStmt(EmitStmt),
    RevertStmt(RevertStmt),
    AssemblyStmt(AssemblyStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum VariableDeclarationItem {
    VariableDeclaration(VariableDeclaration),
    VariableTupleDeclaration(VariableTupleDeclaration),
}
impl AstNode for Name {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NameRef {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAME_REF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Path {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PATH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Symbol {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SYMBOL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentPath {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_PATH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentPathType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_PATH_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DataLocation {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DATA_LOCATION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UserDefineableOperator {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USER_DEFINEABLE_OPERATOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StringLiteral {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRING_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for HexStringLiteral {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == HEX_STRING_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DecimalNumberLiteral {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECIMAL_NUMBER_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for HexNumberLiteral {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == HEX_NUMBER_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BoolLiteral {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BOOL_LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ElementaryType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ELEMENTARY_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitSource {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_SOURCE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Pragma {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRAGMA
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Import {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IMPORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Using {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Contract {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTRACT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedFunctionDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_FUNCTION_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StateVariableDeclaration {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STATE_VARIABLE_DECLARATION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EnumDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UserDefinedValueTypeDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USER_DEFINED_VALUE_TYPE_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ErrorDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ERROR_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EventDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EVENT_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PragmaData {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PRAGMA_DATA
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ImportPath {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IMPORT_PATH
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ImportSymbols {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IMPORT_SYMBOLS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SymbolAliases {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SYMBOL_ALIASES
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SymbolAlias {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SYMBOL_ALIAS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UsingTarget {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USING_TARGET
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UsingAliases {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USING_ALIASES
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UsingAlias {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == USING_ALIAS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FunctionType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MappingType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAPPING_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ArrayType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ARRAY_TYPE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParameterList {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PARAMETER_LIST
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FunctionModifier {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_MODIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Returns {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURNS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VariableDeclaration {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VARIABLE_DECLARATION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MappingKey {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAPPING_KEY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MappingValue {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAPPING_VALUE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IndexExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDEX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SliceExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SLICE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MemberAccessExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MEMBER_ACCESS_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NewExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NEW_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypeExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PostfixExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == POSTFIX_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallOptionsExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_OPTIONS_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TernaryExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TERNARY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TupleExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TUPLE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralExpr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallOptions {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_OPTIONS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallOption {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_OPTION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallArguments {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CALL_ARGUMENTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedCallArguments {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_CALL_ARGUMENTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedCallArgument {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_CALL_ARGUMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Inheritance {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INHERITANCE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InheritanceSpecifier {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INHERITANCE_SPECIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConstructorDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTRUCTOR_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModifierDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODIFIER_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FallbackFunctionDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FALLBACK_FUNCTION_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReceiveFunctionDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RECEIVE_FUNCTION_DEFINITION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FunctionAttribute {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNCTION_ATTRIBUTE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Block {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BLOCK
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModifierAttribute {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODIFIER_ATTRIBUTE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OverrideSpecifier {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OVERRIDE_SPECIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModifierInvocation {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODIFIER_INVOCATION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructMember {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCT_MEMBER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EnumMember {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ENUM_MEMBER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StateVariableAttribute {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STATE_VARIABLE_ATTRIBUTE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EventParameter {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EVENT_PARAMETER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ErrorParameter {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ERROR_PARAMETER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IF_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VariableDeclarationStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VARIABLE_DECLARATION_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FOR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DoWhileStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DO_WHILE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONTINUE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BREAK_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RETURN_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for EmitStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EMIT_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RevertStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REVERT_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssemblyStmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSEMBLY_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VariableTupleDeclaration {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VARIABLE_TUPLE_DECLARATION
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VariableTupleElement {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VARIABLE_TUPLE_ELEMENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CatchClause {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CATCH_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssemblyFlag {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSEMBLY_FLAG
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<StringLiteral> for Literal {
    fn from(node: StringLiteral) -> Literal {
        Literal::StringLiteral(node)
    }
}
impl From<HexStringLiteral> for Literal {
    fn from(node: HexStringLiteral) -> Literal {
        Literal::HexStringLiteral(node)
    }
}
impl From<DecimalNumberLiteral> for Literal {
    fn from(node: DecimalNumberLiteral) -> Literal {
        Literal::DecimalNumberLiteral(node)
    }
}
impl From<HexNumberLiteral> for Literal {
    fn from(node: HexNumberLiteral) -> Literal {
        Literal::HexNumberLiteral(node)
    }
}
impl From<BoolLiteral> for Literal {
    fn from(node: BoolLiteral) -> Literal {
        Literal::BoolLiteral(node)
    }
}
impl AstNode for Literal {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            STRING_LITERAL
                | HEX_STRING_LITERAL
                | DECIMAL_NUMBER_LITERAL
                | HEX_NUMBER_LITERAL
                | BOOL_LITERAL
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            STRING_LITERAL => Literal::StringLiteral(StringLiteral { syntax }),
            HEX_STRING_LITERAL => Literal::HexStringLiteral(HexStringLiteral { syntax }),
            DECIMAL_NUMBER_LITERAL => {
                Literal::DecimalNumberLiteral(DecimalNumberLiteral { syntax })
            }
            HEX_NUMBER_LITERAL => Literal::HexNumberLiteral(HexNumberLiteral { syntax }),
            BOOL_LITERAL => Literal::BoolLiteral(BoolLiteral { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Literal::StringLiteral(it) => &it.syntax,
            Literal::HexStringLiteral(it) => &it.syntax,
            Literal::DecimalNumberLiteral(it) => &it.syntax,
            Literal::HexNumberLiteral(it) => &it.syntax,
            Literal::BoolLiteral(it) => &it.syntax,
        }
    }
}
impl From<Pragma> for Item {
    fn from(node: Pragma) -> Item {
        Item::Pragma(node)
    }
}
impl From<Import> for Item {
    fn from(node: Import) -> Item {
        Item::Import(node)
    }
}
impl From<Using> for Item {
    fn from(node: Using) -> Item {
        Item::Using(node)
    }
}
impl From<Contract> for Item {
    fn from(node: Contract) -> Item {
        Item::Contract(node)
    }
}
impl From<NamedFunctionDefinition> for Item {
    fn from(node: NamedFunctionDefinition) -> Item {
        Item::NamedFunctionDefinition(node)
    }
}
impl From<StateVariableDeclaration> for Item {
    fn from(node: StateVariableDeclaration) -> Item {
        Item::StateVariableDeclaration(node)
    }
}
impl From<StructDefinition> for Item {
    fn from(node: StructDefinition) -> Item {
        Item::StructDefinition(node)
    }
}
impl From<EnumDefinition> for Item {
    fn from(node: EnumDefinition) -> Item {
        Item::EnumDefinition(node)
    }
}
impl From<UserDefinedValueTypeDefinition> for Item {
    fn from(node: UserDefinedValueTypeDefinition) -> Item {
        Item::UserDefinedValueTypeDefinition(node)
    }
}
impl From<ErrorDefinition> for Item {
    fn from(node: ErrorDefinition) -> Item {
        Item::ErrorDefinition(node)
    }
}
impl From<EventDefinition> for Item {
    fn from(node: EventDefinition) -> Item {
        Item::EventDefinition(node)
    }
}
impl AstNode for Item {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            PRAGMA
                | IMPORT
                | USING
                | CONTRACT
                | NAMED_FUNCTION_DEFINITION
                | STATE_VARIABLE_DECLARATION
                | STRUCT_DEFINITION
                | ENUM_DEFINITION
                | USER_DEFINED_VALUE_TYPE_DEFINITION
                | ERROR_DEFINITION
                | EVENT_DEFINITION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PRAGMA => Item::Pragma(Pragma { syntax }),
            IMPORT => Item::Import(Import { syntax }),
            USING => Item::Using(Using { syntax }),
            CONTRACT => Item::Contract(Contract { syntax }),
            NAMED_FUNCTION_DEFINITION => {
                Item::NamedFunctionDefinition(NamedFunctionDefinition { syntax })
            }
            STATE_VARIABLE_DECLARATION => {
                Item::StateVariableDeclaration(StateVariableDeclaration { syntax })
            }
            STRUCT_DEFINITION => Item::StructDefinition(StructDefinition { syntax }),
            ENUM_DEFINITION => Item::EnumDefinition(EnumDefinition { syntax }),
            USER_DEFINED_VALUE_TYPE_DEFINITION => {
                Item::UserDefinedValueTypeDefinition(UserDefinedValueTypeDefinition { syntax })
            }
            ERROR_DEFINITION => Item::ErrorDefinition(ErrorDefinition { syntax }),
            EVENT_DEFINITION => Item::EventDefinition(EventDefinition { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::Pragma(it) => &it.syntax,
            Item::Import(it) => &it.syntax,
            Item::Using(it) => &it.syntax,
            Item::Contract(it) => &it.syntax,
            Item::NamedFunctionDefinition(it) => &it.syntax,
            Item::StateVariableDeclaration(it) => &it.syntax,
            Item::StructDefinition(it) => &it.syntax,
            Item::EnumDefinition(it) => &it.syntax,
            Item::UserDefinedValueTypeDefinition(it) => &it.syntax,
            Item::ErrorDefinition(it) => &it.syntax,
            Item::EventDefinition(it) => &it.syntax,
        }
    }
}
impl From<ImportPath> for ImportItem {
    fn from(node: ImportPath) -> ImportItem {
        ImportItem::ImportPath(node)
    }
}
impl From<ImportSymbols> for ImportItem {
    fn from(node: ImportSymbols) -> ImportItem {
        ImportItem::ImportSymbols(node)
    }
}
impl AstNode for ImportItem {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IMPORT_PATH | IMPORT_SYMBOLS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IMPORT_PATH => ImportItem::ImportPath(ImportPath { syntax }),
            IMPORT_SYMBOLS => ImportItem::ImportSymbols(ImportSymbols { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ImportItem::ImportPath(it) => &it.syntax,
            ImportItem::ImportSymbols(it) => &it.syntax,
        }
    }
}
impl From<IdentPath> for UsingItem {
    fn from(node: IdentPath) -> UsingItem {
        UsingItem::IdentPath(node)
    }
}
impl From<UsingAliases> for UsingItem {
    fn from(node: UsingAliases) -> UsingItem {
        UsingItem::UsingAliases(node)
    }
}
impl AstNode for UsingItem {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_PATH | USING_ALIASES)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PATH => UsingItem::IdentPath(IdentPath { syntax }),
            USING_ALIASES => UsingItem::UsingAliases(UsingAliases { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            UsingItem::IdentPath(it) => &it.syntax,
            UsingItem::UsingAliases(it) => &it.syntax,
        }
    }
}
impl From<ElementaryType> for Type {
    fn from(node: ElementaryType) -> Type {
        Type::ElementaryType(node)
    }
}
impl From<FunctionType> for Type {
    fn from(node: FunctionType) -> Type {
        Type::FunctionType(node)
    }
}
impl From<MappingType> for Type {
    fn from(node: MappingType) -> Type {
        Type::MappingType(node)
    }
}
impl From<IdentPathType> for Type {
    fn from(node: IdentPathType) -> Type {
        Type::IdentPathType(node)
    }
}
impl From<ArrayType> for Type {
    fn from(node: ArrayType) -> Type {
        Type::ArrayType(node)
    }
}
impl AstNode for Type {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ELEMENTARY_TYPE | FUNCTION_TYPE | MAPPING_TYPE | IDENT_PATH_TYPE | ARRAY_TYPE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ELEMENTARY_TYPE => Type::ElementaryType(ElementaryType { syntax }),
            FUNCTION_TYPE => Type::FunctionType(FunctionType { syntax }),
            MAPPING_TYPE => Type::MappingType(MappingType { syntax }),
            IDENT_PATH_TYPE => Type::IdentPathType(IdentPathType { syntax }),
            ARRAY_TYPE => Type::ArrayType(ArrayType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::ElementaryType(it) => &it.syntax,
            Type::FunctionType(it) => &it.syntax,
            Type::MappingType(it) => &it.syntax,
            Type::IdentPathType(it) => &it.syntax,
            Type::ArrayType(it) => &it.syntax,
        }
    }
}
impl From<IndexExpr> for Expr {
    fn from(node: IndexExpr) -> Expr {
        Expr::IndexExpr(node)
    }
}
impl From<SliceExpr> for Expr {
    fn from(node: SliceExpr) -> Expr {
        Expr::SliceExpr(node)
    }
}
impl From<MemberAccessExpr> for Expr {
    fn from(node: MemberAccessExpr) -> Expr {
        Expr::MemberAccessExpr(node)
    }
}
impl From<NewExpr> for Expr {
    fn from(node: NewExpr) -> Expr {
        Expr::NewExpr(node)
    }
}
impl From<TypeExpr> for Expr {
    fn from(node: TypeExpr) -> Expr {
        Expr::TypeExpr(node)
    }
}
impl From<InfixExpr> for Expr {
    fn from(node: InfixExpr) -> Expr {
        Expr::InfixExpr(node)
    }
}
impl From<PrefixExpr> for Expr {
    fn from(node: PrefixExpr) -> Expr {
        Expr::PrefixExpr(node)
    }
}
impl From<PostfixExpr> for Expr {
    fn from(node: PostfixExpr) -> Expr {
        Expr::PostfixExpr(node)
    }
}
impl From<CallOptionsExpr> for Expr {
    fn from(node: CallOptionsExpr) -> Expr {
        Expr::CallOptionsExpr(node)
    }
}
impl From<CallExpr> for Expr {
    fn from(node: CallExpr) -> Expr {
        Expr::CallExpr(node)
    }
}
impl From<TernaryExpr> for Expr {
    fn from(node: TernaryExpr) -> Expr {
        Expr::TernaryExpr(node)
    }
}
impl From<TupleExpr> for Expr {
    fn from(node: TupleExpr) -> Expr {
        Expr::TupleExpr(node)
    }
}
impl From<IdentExpr> for Expr {
    fn from(node: IdentExpr) -> Expr {
        Expr::IdentExpr(node)
    }
}
impl From<LiteralExpr> for Expr {
    fn from(node: LiteralExpr) -> Expr {
        Expr::LiteralExpr(node)
    }
}
impl From<ElementaryType> for Expr {
    fn from(node: ElementaryType) -> Expr {
        Expr::ElementaryType(node)
    }
}
impl AstNode for Expr {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            INDEX_EXPR
                | SLICE_EXPR
                | MEMBER_ACCESS_EXPR
                | NEW_EXPR
                | TYPE_EXPR
                | INFIX_EXPR
                | PREFIX_EXPR
                | POSTFIX_EXPR
                | CALL_OPTIONS_EXPR
                | CALL_EXPR
                | TERNARY_EXPR
                | TUPLE_EXPR
                | IDENT_EXPR
                | LITERAL_EXPR
                | ELEMENTARY_TYPE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            SLICE_EXPR => Expr::SliceExpr(SliceExpr { syntax }),
            MEMBER_ACCESS_EXPR => Expr::MemberAccessExpr(MemberAccessExpr { syntax }),
            NEW_EXPR => Expr::NewExpr(NewExpr { syntax }),
            TYPE_EXPR => Expr::TypeExpr(TypeExpr { syntax }),
            INFIX_EXPR => Expr::InfixExpr(InfixExpr { syntax }),
            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),
            POSTFIX_EXPR => Expr::PostfixExpr(PostfixExpr { syntax }),
            CALL_OPTIONS_EXPR => Expr::CallOptionsExpr(CallOptionsExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            TERNARY_EXPR => Expr::TernaryExpr(TernaryExpr { syntax }),
            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),
            IDENT_EXPR => Expr::IdentExpr(IdentExpr { syntax }),
            LITERAL_EXPR => Expr::LiteralExpr(LiteralExpr { syntax }),
            ELEMENTARY_TYPE => Expr::ElementaryType(ElementaryType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::IndexExpr(it) => &it.syntax,
            Expr::SliceExpr(it) => &it.syntax,
            Expr::MemberAccessExpr(it) => &it.syntax,
            Expr::NewExpr(it) => &it.syntax,
            Expr::TypeExpr(it) => &it.syntax,
            Expr::InfixExpr(it) => &it.syntax,
            Expr::PrefixExpr(it) => &it.syntax,
            Expr::PostfixExpr(it) => &it.syntax,
            Expr::CallOptionsExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::TernaryExpr(it) => &it.syntax,
            Expr::TupleExpr(it) => &it.syntax,
            Expr::IdentExpr(it) => &it.syntax,
            Expr::LiteralExpr(it) => &it.syntax,
            Expr::ElementaryType(it) => &it.syntax,
        }
    }
}
impl From<ElementaryType> for MappingKeyType {
    fn from(node: ElementaryType) -> MappingKeyType {
        MappingKeyType::ElementaryType(node)
    }
}
impl From<IdentPath> for MappingKeyType {
    fn from(node: IdentPath) -> MappingKeyType {
        MappingKeyType::IdentPath(node)
    }
}
impl AstNode for MappingKeyType {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ELEMENTARY_TYPE | IDENT_PATH)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ELEMENTARY_TYPE => MappingKeyType::ElementaryType(ElementaryType { syntax }),
            IDENT_PATH => MappingKeyType::IdentPath(IdentPath { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MappingKeyType::ElementaryType(it) => &it.syntax,
            MappingKeyType::IdentPath(it) => &it.syntax,
        }
    }
}
impl From<CallArguments> for CallArgumentList {
    fn from(node: CallArguments) -> CallArgumentList {
        CallArgumentList::CallArguments(node)
    }
}
impl From<NamedCallArguments> for CallArgumentList {
    fn from(node: NamedCallArguments) -> CallArgumentList {
        CallArgumentList::NamedCallArguments(node)
    }
}
impl AstNode for CallArgumentList {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CALL_ARGUMENTS | NAMED_CALL_ARGUMENTS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CALL_ARGUMENTS => CallArgumentList::CallArguments(CallArguments { syntax }),
            NAMED_CALL_ARGUMENTS => {
                CallArgumentList::NamedCallArguments(NamedCallArguments { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            CallArgumentList::CallArguments(it) => &it.syntax,
            CallArgumentList::NamedCallArguments(it) => &it.syntax,
        }
    }
}
impl From<ConstructorDefinition> for ContractItem {
    fn from(node: ConstructorDefinition) -> ContractItem {
        ContractItem::ConstructorDefinition(node)
    }
}
impl From<ModifierDefinition> for ContractItem {
    fn from(node: ModifierDefinition) -> ContractItem {
        ContractItem::ModifierDefinition(node)
    }
}
impl From<NamedFunctionDefinition> for ContractItem {
    fn from(node: NamedFunctionDefinition) -> ContractItem {
        ContractItem::NamedFunctionDefinition(node)
    }
}
impl From<FallbackFunctionDefinition> for ContractItem {
    fn from(node: FallbackFunctionDefinition) -> ContractItem {
        ContractItem::FallbackFunctionDefinition(node)
    }
}
impl From<ReceiveFunctionDefinition> for ContractItem {
    fn from(node: ReceiveFunctionDefinition) -> ContractItem {
        ContractItem::ReceiveFunctionDefinition(node)
    }
}
impl From<StructDefinition> for ContractItem {
    fn from(node: StructDefinition) -> ContractItem {
        ContractItem::StructDefinition(node)
    }
}
impl From<EnumDefinition> for ContractItem {
    fn from(node: EnumDefinition) -> ContractItem {
        ContractItem::EnumDefinition(node)
    }
}
impl From<UserDefinedValueTypeDefinition> for ContractItem {
    fn from(node: UserDefinedValueTypeDefinition) -> ContractItem {
        ContractItem::UserDefinedValueTypeDefinition(node)
    }
}
impl From<StateVariableDeclaration> for ContractItem {
    fn from(node: StateVariableDeclaration) -> ContractItem {
        ContractItem::StateVariableDeclaration(node)
    }
}
impl From<EventDefinition> for ContractItem {
    fn from(node: EventDefinition) -> ContractItem {
        ContractItem::EventDefinition(node)
    }
}
impl From<ErrorDefinition> for ContractItem {
    fn from(node: ErrorDefinition) -> ContractItem {
        ContractItem::ErrorDefinition(node)
    }
}
impl From<Using> for ContractItem {
    fn from(node: Using) -> ContractItem {
        ContractItem::Using(node)
    }
}
impl AstNode for ContractItem {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONSTRUCTOR_DEFINITION
                | MODIFIER_DEFINITION
                | NAMED_FUNCTION_DEFINITION
                | FALLBACK_FUNCTION_DEFINITION
                | RECEIVE_FUNCTION_DEFINITION
                | STRUCT_DEFINITION
                | ENUM_DEFINITION
                | USER_DEFINED_VALUE_TYPE_DEFINITION
                | STATE_VARIABLE_DECLARATION
                | EVENT_DEFINITION
                | ERROR_DEFINITION
                | USING
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONSTRUCTOR_DEFINITION => {
                ContractItem::ConstructorDefinition(ConstructorDefinition { syntax })
            }
            MODIFIER_DEFINITION => ContractItem::ModifierDefinition(ModifierDefinition { syntax }),
            NAMED_FUNCTION_DEFINITION => {
                ContractItem::NamedFunctionDefinition(NamedFunctionDefinition { syntax })
            }
            FALLBACK_FUNCTION_DEFINITION => {
                ContractItem::FallbackFunctionDefinition(FallbackFunctionDefinition { syntax })
            }
            RECEIVE_FUNCTION_DEFINITION => {
                ContractItem::ReceiveFunctionDefinition(ReceiveFunctionDefinition { syntax })
            }
            STRUCT_DEFINITION => ContractItem::StructDefinition(StructDefinition { syntax }),
            ENUM_DEFINITION => ContractItem::EnumDefinition(EnumDefinition { syntax }),
            USER_DEFINED_VALUE_TYPE_DEFINITION => {
                ContractItem::UserDefinedValueTypeDefinition(UserDefinedValueTypeDefinition {
                    syntax,
                })
            }
            STATE_VARIABLE_DECLARATION => {
                ContractItem::StateVariableDeclaration(StateVariableDeclaration { syntax })
            }
            EVENT_DEFINITION => ContractItem::EventDefinition(EventDefinition { syntax }),
            ERROR_DEFINITION => ContractItem::ErrorDefinition(ErrorDefinition { syntax }),
            USING => ContractItem::Using(Using { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ContractItem::ConstructorDefinition(it) => &it.syntax,
            ContractItem::ModifierDefinition(it) => &it.syntax,
            ContractItem::NamedFunctionDefinition(it) => &it.syntax,
            ContractItem::FallbackFunctionDefinition(it) => &it.syntax,
            ContractItem::ReceiveFunctionDefinition(it) => &it.syntax,
            ContractItem::StructDefinition(it) => &it.syntax,
            ContractItem::EnumDefinition(it) => &it.syntax,
            ContractItem::UserDefinedValueTypeDefinition(it) => &it.syntax,
            ContractItem::StateVariableDeclaration(it) => &it.syntax,
            ContractItem::EventDefinition(it) => &it.syntax,
            ContractItem::ErrorDefinition(it) => &it.syntax,
            ContractItem::Using(it) => &it.syntax,
        }
    }
}
impl From<NamedFunctionDefinition> for FunctionDefinition {
    fn from(node: NamedFunctionDefinition) -> FunctionDefinition {
        FunctionDefinition::NamedFunctionDefinition(node)
    }
}
impl From<FallbackFunctionDefinition> for FunctionDefinition {
    fn from(node: FallbackFunctionDefinition) -> FunctionDefinition {
        FunctionDefinition::FallbackFunctionDefinition(node)
    }
}
impl From<ReceiveFunctionDefinition> for FunctionDefinition {
    fn from(node: ReceiveFunctionDefinition) -> FunctionDefinition {
        FunctionDefinition::ReceiveFunctionDefinition(node)
    }
}
impl AstNode for FunctionDefinition {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            NAMED_FUNCTION_DEFINITION | FALLBACK_FUNCTION_DEFINITION | RECEIVE_FUNCTION_DEFINITION
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_FUNCTION_DEFINITION => {
                FunctionDefinition::NamedFunctionDefinition(NamedFunctionDefinition { syntax })
            }
            FALLBACK_FUNCTION_DEFINITION => {
                FunctionDefinition::FallbackFunctionDefinition(FallbackFunctionDefinition {
                    syntax,
                })
            }
            RECEIVE_FUNCTION_DEFINITION => {
                FunctionDefinition::ReceiveFunctionDefinition(ReceiveFunctionDefinition { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FunctionDefinition::NamedFunctionDefinition(it) => &it.syntax,
            FunctionDefinition::FallbackFunctionDefinition(it) => &it.syntax,
            FunctionDefinition::ReceiveFunctionDefinition(it) => &it.syntax,
        }
    }
}
impl From<Block> for Stmt {
    fn from(node: Block) -> Stmt {
        Stmt::Block(node)
    }
}
impl From<ExprStmt> for Stmt {
    fn from(node: ExprStmt) -> Stmt {
        Stmt::ExprStmt(node)
    }
}
impl From<IfStmt> for Stmt {
    fn from(node: IfStmt) -> Stmt {
        Stmt::IfStmt(node)
    }
}
impl From<VariableDeclarationStmt> for Stmt {
    fn from(node: VariableDeclarationStmt) -> Stmt {
        Stmt::VariableDeclarationStmt(node)
    }
}
impl From<ForStmt> for Stmt {
    fn from(node: ForStmt) -> Stmt {
        Stmt::ForStmt(node)
    }
}
impl From<WhileStmt> for Stmt {
    fn from(node: WhileStmt) -> Stmt {
        Stmt::WhileStmt(node)
    }
}
impl From<DoWhileStmt> for Stmt {
    fn from(node: DoWhileStmt) -> Stmt {
        Stmt::DoWhileStmt(node)
    }
}
impl From<ContinueStmt> for Stmt {
    fn from(node: ContinueStmt) -> Stmt {
        Stmt::ContinueStmt(node)
    }
}
impl From<BreakStmt> for Stmt {
    fn from(node: BreakStmt) -> Stmt {
        Stmt::BreakStmt(node)
    }
}
impl From<TryStmt> for Stmt {
    fn from(node: TryStmt) -> Stmt {
        Stmt::TryStmt(node)
    }
}
impl From<ReturnStmt> for Stmt {
    fn from(node: ReturnStmt) -> Stmt {
        Stmt::ReturnStmt(node)
    }
}
impl From<EmitStmt> for Stmt {
    fn from(node: EmitStmt) -> Stmt {
        Stmt::EmitStmt(node)
    }
}
impl From<RevertStmt> for Stmt {
    fn from(node: RevertStmt) -> Stmt {
        Stmt::RevertStmt(node)
    }
}
impl From<AssemblyStmt> for Stmt {
    fn from(node: AssemblyStmt) -> Stmt {
        Stmt::AssemblyStmt(node)
    }
}
impl AstNode for Stmt {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BLOCK
                | EXPR_STMT
                | IF_STMT
                | VARIABLE_DECLARATION_STMT
                | FOR_STMT
                | WHILE_STMT
                | DO_WHILE_STMT
                | CONTINUE_STMT
                | BREAK_STMT
                | TRY_STMT
                | RETURN_STMT
                | EMIT_STMT
                | REVERT_STMT
                | ASSEMBLY_STMT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BLOCK => Stmt::Block(Block { syntax }),
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            IF_STMT => Stmt::IfStmt(IfStmt { syntax }),
            VARIABLE_DECLARATION_STMT => {
                Stmt::VariableDeclarationStmt(VariableDeclarationStmt { syntax })
            }
            FOR_STMT => Stmt::ForStmt(ForStmt { syntax }),
            WHILE_STMT => Stmt::WhileStmt(WhileStmt { syntax }),
            DO_WHILE_STMT => Stmt::DoWhileStmt(DoWhileStmt { syntax }),
            CONTINUE_STMT => Stmt::ContinueStmt(ContinueStmt { syntax }),
            BREAK_STMT => Stmt::BreakStmt(BreakStmt { syntax }),
            TRY_STMT => Stmt::TryStmt(TryStmt { syntax }),
            RETURN_STMT => Stmt::ReturnStmt(ReturnStmt { syntax }),
            EMIT_STMT => Stmt::EmitStmt(EmitStmt { syntax }),
            REVERT_STMT => Stmt::RevertStmt(RevertStmt { syntax }),
            ASSEMBLY_STMT => Stmt::AssemblyStmt(AssemblyStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::Block(it) => &it.syntax,
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::IfStmt(it) => &it.syntax,
            Stmt::VariableDeclarationStmt(it) => &it.syntax,
            Stmt::ForStmt(it) => &it.syntax,
            Stmt::WhileStmt(it) => &it.syntax,
            Stmt::DoWhileStmt(it) => &it.syntax,
            Stmt::ContinueStmt(it) => &it.syntax,
            Stmt::BreakStmt(it) => &it.syntax,
            Stmt::TryStmt(it) => &it.syntax,
            Stmt::ReturnStmt(it) => &it.syntax,
            Stmt::EmitStmt(it) => &it.syntax,
            Stmt::RevertStmt(it) => &it.syntax,
            Stmt::AssemblyStmt(it) => &it.syntax,
        }
    }
}
impl From<VariableDeclaration> for VariableDeclarationItem {
    fn from(node: VariableDeclaration) -> VariableDeclarationItem {
        VariableDeclarationItem::VariableDeclaration(node)
    }
}
impl From<VariableTupleDeclaration> for VariableDeclarationItem {
    fn from(node: VariableTupleDeclaration) -> VariableDeclarationItem {
        VariableDeclarationItem::VariableTupleDeclaration(node)
    }
}
impl AstNode for VariableDeclarationItem {
    type Language = SolidityLang;
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, VARIABLE_DECLARATION | VARIABLE_TUPLE_DECLARATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            VARIABLE_DECLARATION => {
                VariableDeclarationItem::VariableDeclaration(VariableDeclaration { syntax })
            }
            VARIABLE_TUPLE_DECLARATION => {
                VariableDeclarationItem::VariableTupleDeclaration(VariableTupleDeclaration {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            VariableDeclarationItem::VariableDeclaration(it) => &it.syntax,
            VariableDeclarationItem::VariableTupleDeclaration(it) => &it.syntax,
        }
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UsingItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MappingKeyType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallArgumentList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContractItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariableDeclarationItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Symbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DataLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UserDefineableOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for HexStringLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DecimalNumberLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for HexNumberLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BoolLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElementaryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pragma {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Import {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Using {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Contract {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedFunctionDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StateVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EnumDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UserDefinedValueTypeDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ErrorDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EventDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PragmaData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportSymbols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SymbolAliases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SymbolAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UsingTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UsingAliases {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UsingAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MappingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParameterList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Returns {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MappingKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MappingValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SliceExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberAccessExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NewExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PostfixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallOptionsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TernaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedCallArguments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedCallArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Inheritance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InheritanceSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstructorDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModifierDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FallbackFunctionDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReceiveFunctionDefinition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModifierAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OverrideSpecifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModifierInvocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EnumMember {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StateVariableAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EventParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ErrorParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariableDeclarationStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DoWhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EmitStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RevertStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssemblyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariableTupleDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariableTupleElement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssemblyFlag {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
