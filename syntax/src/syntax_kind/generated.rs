//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Default)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    #[default]
    EOF,
    SEMICOLON,
    COLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    DOT,
    BANG,
    QUESTION,
    EQ,
    EQ2,
    NEQ,
    PLUS,
    PLUSPLUS,
    PLUSEQ,
    STAR,
    STARSTAR,
    STAREQ,
    SLASH,
    SLASHEQ,
    MINUS,
    MINUSMINUS,
    MINUSEQ,
    AMP,
    AMPAMP,
    AMPEQ,
    PIPE,
    PIPEPIPE,
    PIPEEQ,
    PERCENT,
    PERCENTEQ,
    CARET,
    CARETEQ,
    TILDE,
    GT,
    GEQ,
    RSHIFT,
    RSHIFTZERO,
    RSHIFTEQ,
    RSHIFTZEROEQ,
    LT,
    LEQ,
    LSHIFT,
    LSHIFTEQ,
    FAT_ARROW,
    THIN_ARROW,
    PRAGMA_KW,
    IMPORT_KW,
    USING_KW,
    CONTRACT_KW,
    ABSTRACT_KW,
    INTERFACE_KW,
    LIBRARY_KW,
    FUNCTION_KW,
    CONSTANT_KW,
    STRUCT_KW,
    ENUM_KW,
    EVENT_KW,
    PUBLIC_KW,
    PRIVATE_KW,
    INTERNAL_KW,
    EXTERNAL_KW,
    VIRTUAL_KW,
    MODIFIER_KW,
    PURE_KW,
    VIEW_KW,
    RETURNS_KW,
    AS_KW,
    NEW_KW,
    DELETE_KW,
    STORAGE_KW,
    CALLDATA_KW,
    MEMORY_KW,
    MAPPING_KW,
    IS_KW,
    CONSTRUCTOR_KW,
    IF_KW,
    ELSE_KW,
    FOR_KW,
    WHILE_KW,
    DO_KW,
    CONTINUE_KW,
    BREAK_KW,
    TRY_KW,
    RETURN_KW,
    EMIT_KW,
    ASSEMBLY_KW,
    ANONYMOUS_KW,
    INDEXED_KW,
    RECEIVE_KW,
    FALLBACK_KW,
    IMMUTABLE_KW,
    CONST_KW,
    OVERRIDE_KW,
    CATCH_KW,
    WEI_KW,
    GWEI_KW,
    ETHER_KW,
    SECONDS_KW,
    MINUTES_KW,
    HOURS_KW,
    DAYS_KW,
    WEEKS_KW,
    YEARS_KW,
    TRUE_KW,
    FALSE_KW,
    FROM_KW,
    ERROR_KW,
    REVERT_KW,
    GLOBAL_KW,
    TYPE_KW,
    ADDRESS_KW,
    UNCHECKED_KW,
    PAYABLE_KW,
    STRING_LITERAL,
    HEX_STRING_LITERAL,
    DECIMAL_NUMBER_LITERAL,
    HEX_NUMBER_LITERAL,
    BOOL_LITERAL,
    STRING,
    HEX_STRING,
    DECIMAL_NUMBER,
    HEX_NUMBER,
    ERROR,
    IDENT,
    ELEMENTARY_TYPE_IDENT,
    WHITESPACE,
    COMMENT,
    PRAGMA_TOKEN,
    USER_DEFINEABLE_OPERATOR,
    UNIT_SOURCE,
    ITEM,
    NAME,
    NAME_REF,
    SYMBOL,
    PATH,
    PRAGMA,
    PRAGMA_DATA,
    USING,
    USING_ALIASES,
    USING_TARGET,
    USING_BLOCK,
    USING_ITEM,
    USING_ALIAS,
    VISIBILITY,
    STATE_MUTABILITY,
    IMPORT,
    IMPORT_ITEM,
    IMPORT_PATH,
    IMPORT_SYMBOLS,
    IDENT_PATH,
    DATA_LOCATION,
    LITERAL,
    CALL_OPTIONS,
    CALL_OPTION,
    CALL_ARGUMENT_LIST,
    CALL_ARGUMENTS,
    NAMED_CALL_ARGUMENTS,
    NAMED_CALL_ARGUMENT,
    ARGUMENT_LIST,
    PARAMETER_LIST,
    RETURNS,
    SYMBOL_ALIASES,
    SYMBOL_ALIAS,
    INTERFACE,
    LIBRARY,
    CONTRACT,
    CONTRACT_ITEM,
    INHERITANCE_SPECIFIERS,
    INHERITANCE_SPECIFIER,
    MODIFIER_DEFINITION,
    MODIFIER_INVOCATION,
    BLOCK,
    UNCHECKED_BLOCK,
    VARIABLE_DECLARATION,
    VARIABLE_DECLARATION_TUPLE,
    EVENT_DEFINITION,
    EVENT_PARAMETERS,
    EVENT_PARAMETER,
    ERROR_DEFINITION,
    ERROR_PARAMETERS,
    ERROR_PARAMETER,
    OVERRIDE_SPECIFIER,
    FUNCTION_ATTRIBUTE,
    FUNCTION_MODIFIER,
    MODIFIER_ATTRIBUTE,
    STATE_VARIABLE_ATTRIBUTE,
    CONSTRUCTOR_DEFINITION,
    FUNCTION_DEFINITION,
    NAMED_FUNCTION_DEFINITION,
    FALLBACK_FUNCTION_DEFINITION,
    RECEIVE_FUNCTION_DEFINITION,
    INHERITANCE,
    STRUCT_DEFINITION,
    STRUCT_MEMBER,
    ENUM_DEFINITION,
    ENUM_MEMBER,
    USER_DEFINED_VALUE_TYPE_DEFINITION,
    STATE_VARIABLE_DECLARATION,
    SUB_DENOMINATOR,
    YUL_ASSEMBLY,
    CATCH_CLAUSE,
    VARIABLE_TUPLE_DECLARATION,
    VARIABLE_TUPLE_ELEMENT,
    ASSEMBLY_FLAG,
    ELEMENTARY_TYPE,
    ARRAY_TYPE,
    FUNCTION_TYPE,
    MAPPING_TYPE,
    MAPPING_KEY_TYPE,
    IDENT_PATH_TYPE,
    IF_STMT,
    FOR_STMT,
    WHILE_STMT,
    DO_WHILE_STMT,
    CONTINUE_STMT,
    BREAK_STMT,
    TRY_STMT,
    RETURN_STMT,
    EMIT_STMT,
    REVERT_STMT,
    ASSEMBLY_STMT,
    EXPR_STMT,
    VARIABLE_DECLARATION_STMT,
    CALL_EXPR,
    BINARY_EXPR,
    INDEX_EXPR,
    SLICE_EXPR,
    MEMBER_ACCESS_EXPR,
    CALL_OPTIONS_EXPR,
    IDENT_EXPR,
    LITERAL_EXPR,
    NEW_EXPR,
    TUPLE_EXPR,
    INLINE_ARRAY_EXPR,
    PREFIX_EXPR,
    POSTFIX_EXPR,
    INFIX_EXPR,
    TERNARY_EXPR,
    NUMBER_LITERAL_EXPR,
    MAPPING_KEY,
    MAPPING_VALUE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            PRAGMA_KW
                | IMPORT_KW
                | USING_KW
                | CONTRACT_KW
                | ABSTRACT_KW
                | INTERFACE_KW
                | LIBRARY_KW
                | FUNCTION_KW
                | CONSTANT_KW
                | STRUCT_KW
                | ENUM_KW
                | EVENT_KW
                | PUBLIC_KW
                | PRIVATE_KW
                | INTERNAL_KW
                | EXTERNAL_KW
                | VIRTUAL_KW
                | MODIFIER_KW
                | PURE_KW
                | VIEW_KW
                | RETURNS_KW
                | AS_KW
                | NEW_KW
                | DELETE_KW
                | STORAGE_KW
                | CALLDATA_KW
                | MEMORY_KW
                | MAPPING_KW
                | IS_KW
                | CONSTRUCTOR_KW
                | IF_KW
                | ELSE_KW
                | FOR_KW
                | WHILE_KW
                | DO_KW
                | CONTINUE_KW
                | BREAK_KW
                | TRY_KW
                | RETURN_KW
                | EMIT_KW
                | ASSEMBLY_KW
                | ANONYMOUS_KW
                | INDEXED_KW
                | RECEIVE_KW
                | FALLBACK_KW
                | IMMUTABLE_KW
                | CONST_KW
                | OVERRIDE_KW
                | CATCH_KW
                | WEI_KW
                | GWEI_KW
                | ETHER_KW
                | SECONDS_KW
                | MINUTES_KW
                | HOURS_KW
                | DAYS_KW
                | WEEKS_KW
                | YEARS_KW
                | TRUE_KW
                | FALSE_KW
                | FROM_KW
                | ERROR_KW
                | REVERT_KW
                | GLOBAL_KW
                | TYPE_KW
                | ADDRESS_KW
                | UNCHECKED_KW
                | PAYABLE_KW
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            SEMICOLON
                | COLON
                | COMMA
                | L_PAREN
                | R_PAREN
                | L_CURLY
                | R_CURLY
                | L_BRACK
                | R_BRACK
                | DOT
                | BANG
                | QUESTION
                | EQ
                | EQ2
                | NEQ
                | PLUS
                | PLUSPLUS
                | PLUSEQ
                | STAR
                | STARSTAR
                | STAREQ
                | SLASH
                | SLASHEQ
                | MINUS
                | MINUSMINUS
                | MINUSEQ
                | AMP
                | AMPAMP
                | AMPEQ
                | PIPE
                | PIPEPIPE
                | PIPEEQ
                | PERCENT
                | PERCENTEQ
                | CARET
                | CARETEQ
                | TILDE
                | GT
                | GEQ
                | RSHIFT
                | RSHIFTZERO
                | RSHIFTEQ
                | RSHIFTZEROEQ
                | LT
                | LEQ
                | LSHIFT
                | LSHIFTEQ
                | FAT_ARROW
                | THIN_ARROW
        )
    }
    fn is_elementary_type(text: &str) -> bool {
        if matches!(text, "bool" | "string" | "bytes" | "int" | "uint" | "fixed" | "ufixed") {
            return true;
        }
        if let Some(n) = text.strip_prefix("bytes") {
            if let Ok(n) = n.parse::<u8>() {
                return (1..=32).contains(&n);
            }
        } else {
            let text = text.strip_prefix('u').unwrap_or(text);
            if let Some(n) = text.strip_prefix("int") {
                if let Ok(n) = n.parse::<u16>() {
                    return n % 8 == 0 && (8..=256).contains(&n);
                }
            }
            if let Some(n) = text.strip_prefix("fixed") {
                if let Some((m, n)) = n.split_once('x') {
                    if let Ok((m, n)) =
                        m.parse::<u16>().and_then(|m| n.parse::<u8>().map(|n| (m, n)))
                    {
                        return m % 8 == 0 && (8..=256).contains(&m) && (0..=80).contains(&n);
                    }
                }
            }
        }
        false
    }
    pub fn is_literal(self) -> bool {
        matches!(
            self,
            STRING_LITERAL
                | HEX_STRING_LITERAL
                | DECIMAL_NUMBER_LITERAL
                | HEX_NUMBER_LITERAL
                | BOOL_LITERAL
        )
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "pragma" => PRAGMA_KW,
            "import" => IMPORT_KW,
            "using" => USING_KW,
            "contract" => CONTRACT_KW,
            "abstract" => ABSTRACT_KW,
            "interface" => INTERFACE_KW,
            "library" => LIBRARY_KW,
            "function" => FUNCTION_KW,
            "constant" => CONSTANT_KW,
            "struct" => STRUCT_KW,
            "enum" => ENUM_KW,
            "event" => EVENT_KW,
            "public" => PUBLIC_KW,
            "private" => PRIVATE_KW,
            "internal" => INTERNAL_KW,
            "external" => EXTERNAL_KW,
            "virtual" => VIRTUAL_KW,
            "modifier" => MODIFIER_KW,
            "pure" => PURE_KW,
            "view" => VIEW_KW,
            "returns" => RETURNS_KW,
            "as" => AS_KW,
            "new" => NEW_KW,
            "delete" => DELETE_KW,
            "storage" => STORAGE_KW,
            "calldata" => CALLDATA_KW,
            "memory" => MEMORY_KW,
            "mapping" => MAPPING_KW,
            "is" => IS_KW,
            "constructor" => CONSTRUCTOR_KW,
            "if" => IF_KW,
            "else" => ELSE_KW,
            "for" => FOR_KW,
            "while" => WHILE_KW,
            "do" => DO_KW,
            "continue" => CONTINUE_KW,
            "break" => BREAK_KW,
            "try" => TRY_KW,
            "return" => RETURN_KW,
            "emit" => EMIT_KW,
            "assembly" => ASSEMBLY_KW,
            "anonymous" => ANONYMOUS_KW,
            "indexed" => INDEXED_KW,
            "receive" => RECEIVE_KW,
            "fallback" => FALLBACK_KW,
            "immutable" => IMMUTABLE_KW,
            "const" => CONST_KW,
            "override" => OVERRIDE_KW,
            "catch" => CATCH_KW,
            "wei" => WEI_KW,
            "gwei" => GWEI_KW,
            "ether" => ETHER_KW,
            "seconds" => SECONDS_KW,
            "minutes" => MINUTES_KW,
            "hours" => HOURS_KW,
            "days" => DAYS_KW,
            "weeks" => WEEKS_KW,
            "years" => YEARS_KW,
            "true" => TRUE_KW,
            "false" => FALSE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_contextual_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "from" => FROM_KW,
            "error" => ERROR_KW,
            "revert" => REVERT_KW,
            "global" => GLOBAL_KW,
            "type" => TYPE_KW,
            "address" => ADDRESS_KW,
            "unchecked" => UNCHECKED_KW,
            "payable" => PAYABLE_KW,
            _ if Self::is_elementary_type(ident) => ELEMENTARY_TYPE,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ';' => SEMICOLON,
            ':' => COLON,
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '.' => DOT,
            '!' => BANG,
            '?' => QUESTION,
            '=' => EQ,
            '+' => PLUS,
            '*' => STAR,
            '/' => SLASH,
            '-' => MINUS,
            '&' => AMP,
            '|' => PIPE,
            '%' => PERCENT,
            '^' => CARET,
            '~' => TILDE,
            '>' => GT,
            '<' => LT,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [++] => { $ crate :: SyntaxKind :: PLUSPLUS } ; [+=] => { $ crate :: SyntaxKind :: PLUSEQ } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [**] => { $ crate :: SyntaxKind :: STARSTAR } ; [*=] => { $ crate :: SyntaxKind :: STAREQ } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [/=] => { $ crate :: SyntaxKind :: SLASHEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [--] => { $ crate :: SyntaxKind :: MINUSMINUS } ; [-=] => { $ crate :: SyntaxKind :: MINUSEQ } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [&&] => { $ crate :: SyntaxKind :: AMPAMP } ; [&=] => { $ crate :: SyntaxKind :: AMPEQ } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [||] => { $ crate :: SyntaxKind :: PIPEPIPE } ; [|=] => { $ crate :: SyntaxKind :: PIPEEQ } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [%=] => { $ crate :: SyntaxKind :: PERCENTEQ } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [^=] => { $ crate :: SyntaxKind :: CARETEQ } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [>] => { $ crate :: SyntaxKind :: GT } ; [>=] => { $ crate :: SyntaxKind :: GEQ } ; [>>] => { $ crate :: SyntaxKind :: RSHIFT } ; [>>>] => { $ crate :: SyntaxKind :: RSHIFTZERO } ; [>>=] => { $ crate :: SyntaxKind :: RSHIFTEQ } ; [>>>=] => { $ crate :: SyntaxKind :: RSHIFTZEROEQ } ; [<] => { $ crate :: SyntaxKind :: LT } ; [<=] => { $ crate :: SyntaxKind :: LEQ } ; [<<] => { $ crate :: SyntaxKind :: LSHIFT } ; [<<=] => { $ crate :: SyntaxKind :: LSHIFTEQ } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [->] => { $ crate :: SyntaxKind :: THIN_ARROW } ; [pragma] => { $ crate :: SyntaxKind :: PRAGMA_KW } ; [import] => { $ crate :: SyntaxKind :: IMPORT_KW } ; [using] => { $ crate :: SyntaxKind :: USING_KW } ; [contract] => { $ crate :: SyntaxKind :: CONTRACT_KW } ; [abstract] => { $ crate :: SyntaxKind :: ABSTRACT_KW } ; [interface] => { $ crate :: SyntaxKind :: INTERFACE_KW } ; [library] => { $ crate :: SyntaxKind :: LIBRARY_KW } ; [function] => { $ crate :: SyntaxKind :: FUNCTION_KW } ; [constant] => { $ crate :: SyntaxKind :: CONSTANT_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [event] => { $ crate :: SyntaxKind :: EVENT_KW } ; [public] => { $ crate :: SyntaxKind :: PUBLIC_KW } ; [private] => { $ crate :: SyntaxKind :: PRIVATE_KW } ; [internal] => { $ crate :: SyntaxKind :: INTERNAL_KW } ; [external] => { $ crate :: SyntaxKind :: EXTERNAL_KW } ; [virtual] => { $ crate :: SyntaxKind :: VIRTUAL_KW } ; [modifier] => { $ crate :: SyntaxKind :: MODIFIER_KW } ; [pure] => { $ crate :: SyntaxKind :: PURE_KW } ; [view] => { $ crate :: SyntaxKind :: VIEW_KW } ; [returns] => { $ crate :: SyntaxKind :: RETURNS_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [new] => { $ crate :: SyntaxKind :: NEW_KW } ; [delete] => { $ crate :: SyntaxKind :: DELETE_KW } ; [storage] => { $ crate :: SyntaxKind :: STORAGE_KW } ; [calldata] => { $ crate :: SyntaxKind :: CALLDATA_KW } ; [memory] => { $ crate :: SyntaxKind :: MEMORY_KW } ; [mapping] => { $ crate :: SyntaxKind :: MAPPING_KW } ; [is] => { $ crate :: SyntaxKind :: IS_KW } ; [constructor] => { $ crate :: SyntaxKind :: CONSTRUCTOR_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [do] => { $ crate :: SyntaxKind :: DO_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [emit] => { $ crate :: SyntaxKind :: EMIT_KW } ; [assembly] => { $ crate :: SyntaxKind :: ASSEMBLY_KW } ; [anonymous] => { $ crate :: SyntaxKind :: ANONYMOUS_KW } ; [indexed] => { $ crate :: SyntaxKind :: INDEXED_KW } ; [receive] => { $ crate :: SyntaxKind :: RECEIVE_KW } ; [fallback] => { $ crate :: SyntaxKind :: FALLBACK_KW } ; [immutable] => { $ crate :: SyntaxKind :: IMMUTABLE_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [override] => { $ crate :: SyntaxKind :: OVERRIDE_KW } ; [catch] => { $ crate :: SyntaxKind :: CATCH_KW } ; [wei] => { $ crate :: SyntaxKind :: WEI_KW } ; [gwei] => { $ crate :: SyntaxKind :: GWEI_KW } ; [ether] => { $ crate :: SyntaxKind :: ETHER_KW } ; [seconds] => { $ crate :: SyntaxKind :: SECONDS_KW } ; [minutes] => { $ crate :: SyntaxKind :: MINUTES_KW } ; [hours] => { $ crate :: SyntaxKind :: HOURS_KW } ; [days] => { $ crate :: SyntaxKind :: DAYS_KW } ; [weeks] => { $ crate :: SyntaxKind :: WEEKS_KW } ; [years] => { $ crate :: SyntaxKind :: YEARS_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [from] => { $ crate :: SyntaxKind :: FROM_KW } ; [error] => { $ crate :: SyntaxKind :: ERROR_KW } ; [revert] => { $ crate :: SyntaxKind :: REVERT_KW } ; [global] => { $ crate :: SyntaxKind :: GLOBAL_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [address] => { $ crate :: SyntaxKind :: ADDRESS_KW } ; [unchecked] => { $ crate :: SyntaxKind :: UNCHECKED_KW } ; [payable] => { $ crate :: SyntaxKind :: PAYABLE_KW } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [elementary_type_ident] => { $ crate :: SyntaxKind :: ELEMENTARY_TYPE_IDENT } ; [pragma_token] => { $ crate :: SyntaxKind :: PRAGMA_TOKEN } ; [string] => { $ crate :: SyntaxKind :: STRING } ; [hex_string] => { $ crate :: SyntaxKind :: HEX_STRING } ; [decimal_number] => { $ crate :: SyntaxKind :: DECIMAL_NUMBER } ; [hex_number] => { $ crate :: SyntaxKind :: HEX_NUMBER } ; }
